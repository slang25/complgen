use std::io::Write;

use crate::dfa::DFA;
use crate::grammar::{CmdRegex, Specialization};
use crate::regex::Input;
use crate::Result;
use hashbrown::HashMap;
use indexmap::IndexSet;
use ustr::{Ustr, ustr};

// PowerShell completion scripts use Register-ArgumentCompleter
// PowerShell strings use different escaping rules than bash/zsh

pub fn make_string_constant(s: &str) -> String {
    format!(
        "'{}'",
        s.replace('\'', "''")  // PowerShell single quotes escape by doubling
    )
}

pub fn make_id_from_command_map(dfa: &DFA) -> (IndexSet<Ustr>, IndexSet<Ustr>) {
    let mut id_from_cmd: IndexSet<Ustr> = Default::default();
    let mut id_from_regex: IndexSet<Ustr> = Default::default();

    for input in dfa.iter_inputs() {
        match input {
            Input::Nonterminal {
                nonterm: _,
                spec: Some(Specialization { pwsh: Some(cmd), .. }),
                ..
            } => {
                id_from_cmd.insert(*cmd);
            }
            Input::Command { cmd, regex, .. } => {
                id_from_cmd.insert(*cmd);
                if let Some(CmdRegex {
                    pwsh: Some(pwsh_regex),
                    ..
                }) = regex
                {
                    id_from_regex.insert(*pwsh_regex);
                }
            }
            Input::Subword { subdfa, .. } => {
                for input in dfa.subdfa_interner.lookup(*subdfa).iter_inputs() {
                    match input {
                        Input::Nonterminal {
                            spec: Some(Specialization { pwsh: Some(cmd), .. }),
                            ..
                        } => {
                            id_from_cmd.insert(*cmd);
                        }
                        Input::Command { cmd, regex, .. } => {
                            id_from_cmd.insert(*cmd);
                            if let Some(CmdRegex {
                                pwsh: Some(pwsh_regex),
                                ..
                            }) = regex
                            {
                                id_from_regex.insert(*pwsh_regex);
                            }
                        }
                        _ => {}
                    }
                }
            }
            _ => {}
        }
    }

    (id_from_cmd, id_from_regex)
}

fn write_lookup_tables<W: Write>(
    buffer: &mut W,
    dfa: &DFA,
    id_from_regex: &IndexSet<Ustr>,
) -> Result<HashMap<(Ustr, Ustr), usize>> {
    let all_literals: Vec<(usize, Ustr, Ustr)> = dfa
        .get_all_literals()
        .into_iter()
        .enumerate()
        .map(|(id, (literal, description))| (id, literal, description.unwrap_or(ustr(""))))
        .collect();

    let literal_id_from_input_description: HashMap<(Ustr, Ustr), usize> = all_literals
        .iter()
        .map(|(id, input, description)| ((*input, *description), *id))
        .collect();

    // Write literals array
    writeln!(buffer, "    $literals = @(")?;
    for (_, literal, _) in &all_literals {
        writeln!(buffer, "        {},", make_string_constant(literal))?;
    }
    writeln!(buffer, "    )")?;

    // Write descriptions hash table
    let descrs: IndexSet<Ustr> = all_literals
        .iter()
        .map(|(_, _, descr)| *descr)
        .filter(|d| !d.is_empty())
        .collect();
    
    writeln!(buffer, "    $descriptions = @{{}}")?;
    for descr in &descrs {
        if descr.is_empty() {
            continue;
        }
        let id = descrs.get_index_of(descr).unwrap();
        let quoted = make_string_constant(descr);
        writeln!(buffer, "    $descriptions[{}] = {}", id, quoted)?;
    }

    // Write regexes array
    writeln!(buffer, "    $regexes = @(")?;
    for regex in id_from_regex {
        writeln!(buffer, "        {},", make_string_constant(regex))?;
    }
    writeln!(buffer, "    )")?;

    Ok(literal_id_from_input_description)
}

pub fn write_completion_script<W: Write>(buffer: &mut W, command: &str, dfa: &DFA) -> Result<()> {
    let (id_from_cmd, id_from_regex) = make_id_from_command_map(dfa);

    writeln!(buffer, "# PowerShell completion script for {}", command)?;
    writeln!(buffer, "# Generated by complgen")?;
    writeln!(buffer)?;

    // Register the argument completer
    writeln!(buffer, "Register-ArgumentCompleter -CommandName '{}' -ScriptBlock {{", command)?;
    writeln!(buffer, "    param($CommandName, $WordToComplete, $CommandAst, $FakeBoundParameters)")?;
    writeln!(buffer)?;

    // Helper function to execute commands
    writeln!(buffer, "    function Invoke-Command {{")?;
    writeln!(buffer, "        param($CommandId, $Input)")?;
    writeln!(buffer, "        switch ($CommandId) {{")?;
    
    for (cmd_id, cmd) in id_from_cmd.iter().enumerate() {
        writeln!(buffer, "            {} {{ & {} $Input }}", cmd_id, make_string_constant(cmd))?;
    }
    
    writeln!(buffer, "        }}")?;
    writeln!(buffer, "    }}")?;
    writeln!(buffer)?;

    // Write lookup tables
    write_lookup_tables(buffer, dfa, &id_from_regex)?;

    writeln!(buffer)?;
    writeln!(buffer, "    # State machine traversal")?;
    writeln!(buffer, "    $words = $CommandAst.CommandElements | ForEach-Object {{ $_.ToString() }}")?;
    writeln!(buffer, "    $state = {}", dfa.starting_state)?;
    writeln!(buffer, "    $wordIndex = 1  # Skip command name")?;
    writeln!(buffer)?;

    writeln!(buffer, "    # Traverse through completed words")?;
    writeln!(buffer, "    while ($wordIndex -lt $words.Count - 1) {{")?;
    writeln!(buffer, "        $word = $words[$wordIndex]")?;
    writeln!(buffer, "        $matched = $false")?;
    writeln!(buffer)?;

    // Add literal transitions logic
    writeln!(buffer, "        # Try literal transitions")?;
    writeln!(buffer, "        for ($i = 0; $i -lt $literals.Count; $i++) {{")?;
    writeln!(buffer, "            if ($literals[$i] -eq $word) {{")?;
    writeln!(buffer, "                # Check if this literal transition exists from current state")?;
    writeln!(buffer, "                # (Simplified - would need state transition tables here)")?;
    writeln!(buffer, "                $matched = $true")?;
    writeln!(buffer, "                break")?;
    writeln!(buffer, "            }}")?;
    writeln!(buffer, "        }}")?;
    writeln!(buffer)?;

    writeln!(buffer, "        if (-not $matched) {{")?;
    writeln!(buffer, "            break")?;
    writeln!(buffer, "        }}")?;
    writeln!(buffer, "        $wordIndex++")?;
    writeln!(buffer, "    }}")?;
    writeln!(buffer)?;

    // Generate completions
    writeln!(buffer, "    # Generate completions for current position")?;
    writeln!(buffer, "    $completions = @()")?;
    writeln!(buffer)?;

    writeln!(buffer, "    # Add literal completions")?;
    writeln!(buffer, "    foreach ($literal in $literals) {{")?;
    writeln!(buffer, "        if ($literal -like \"$WordToComplete*\") {{")?;
    writeln!(buffer, "            $completions += [System.Management.Automation.CompletionResult]::new($literal, $literal, 'ParameterValue', $literal)")?;
    writeln!(buffer, "        }}")?;
    writeln!(buffer, "    }}")?;
    writeln!(buffer)?;

    // Execute command completions if available
    if !id_from_cmd.is_empty() {
        writeln!(buffer, "    # Execute command completions")?;
        writeln!(buffer, "    foreach ($cmdId in 0..{}) {{", id_from_cmd.len() - 1)?;
        writeln!(buffer, "        try {{")?;
        writeln!(buffer, "            $output = Invoke-Command -CommandId $cmdId -Input $WordToComplete")?;
        writeln!(buffer, "            if ($output) {{")?;
        writeln!(buffer, "                $lines = $output -split \"`n\"")?;
        writeln!(buffer, "                foreach ($line in $lines) {{")?;
        writeln!(buffer, "                    if ($line.Trim()) {{")?;
        writeln!(buffer, "                        $parts = $line -split \"`t\"")?;
        writeln!(buffer, "                        $completion = $parts[0]")?;
        writeln!(buffer, "                        $description = if ($parts.Count -gt 1) {{ $parts[1] }} else {{ $completion }}")?;
        writeln!(buffer, "                        if ($completion -like \"$WordToComplete*\") {{")?;
        writeln!(buffer, "                            $completions += [System.Management.Automation.CompletionResult]::new($completion, $completion, 'ParameterValue', $description)")?;
        writeln!(buffer, "                        }}")?;
        writeln!(buffer, "                    }}")?;
        writeln!(buffer, "                }}")?;
        writeln!(buffer, "            }}")?;
        writeln!(buffer, "        }} catch {{")?;
        writeln!(buffer, "            # Ignore command execution errors")?;
        writeln!(buffer, "        }}")?;
        writeln!(buffer, "    }}")?;
        writeln!(buffer)?;
    }

    writeln!(buffer, "    return $completions")?;
    writeln!(buffer, "}}")?;

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::dfa::DFA;
    use crate::regex::Regex;
    use crate::grammar::{Grammar, ValidGrammar, Shell};

    #[test]
    fn test_basic_pwsh_completion_script_generation() {
        let input = "testcmd foo bar;";
        let grammar = Grammar::parse(input).map_err(|e| e.to_string()).unwrap();
        let validated = ValidGrammar::from_grammar(grammar, Shell::Pwsh).unwrap();
        let regex = Regex::from_expr(validated.expr, &validated.arena, &validated.specializations).unwrap();
        let dfa = DFA::from_regex(&regex, validated.subdfa_interner);
        
        let mut output = Vec::new();
        write_completion_script(&mut output, &validated.command, &dfa).unwrap();
        
        let script = String::from_utf8(output).unwrap();
        
        // Verify basic structure
        assert!(script.contains("Register-ArgumentCompleter"));
        assert!(script.contains("testcmd"));
        assert!(script.contains("'foo'"));
        assert!(script.contains("'bar'"));
        assert!(script.contains("$completions"));
    }

    #[test]
    fn test_make_string_constant() {
        assert_eq!(make_string_constant("simple"), "'simple'");
        assert_eq!(make_string_constant("with'quote"), "'with''quote'");
        assert_eq!(make_string_constant(""), "''");
    }
}